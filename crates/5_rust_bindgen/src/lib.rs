use wasm_bindgen::prelude::*;

mod ffi {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]

    #[allow(dead_code)]
    extern "C" {
        pub fn add(left: u32, right: u32) -> u32;
        pub fn new_calculator() -> *mut Calculator;
        pub fn free_calculator(calculator: *mut Calculator);
    }

    // This looks exactly like the previous example,
    // but the Calculator struct is generated by bindgen.
    // The difference is that it wraps the properties in Option.
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

#[wasm_bindgen]
pub struct Calculator {
    calculator: *mut ffi::Calculator,
}

impl Drop for Calculator {
    fn drop(&mut self) {
        unsafe {
            ffi::free_calculator(self.calculator);
        }
    }
}

impl Default for Calculator {
    fn default() -> Self {
        Self::new()
    }
}

#[wasm_bindgen]
impl Calculator {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Calculator {
        let calculator = unsafe { ffi::new_calculator() };
        Calculator { calculator }
    }

    pub fn add(&self, left: u32, right: u32) -> u32 {
        if let Some(add) = unsafe { (*self.calculator).add } {
            return unsafe { add(left, right) };
        }

        unreachable!("add not implemented")
    }

    pub fn subtract(&self, left: u32, right: u32) -> u32 {
        if let Some(subtract) = unsafe { (*self.calculator).subtract } {
            return unsafe { subtract(left, right) };
        }

        unreachable!("subtract not implemented")
    }

    pub fn multiply(&self, left: u32, right: u32) -> u32 {
        if let Some(multiply) = unsafe { (*self.calculator).multiply } {
            return unsafe { multiply(left, right) };
        }

        unreachable!("multiply not implemented")
    }

    pub fn divide(&self, left: u32, right: u32) -> u32 {
        if let Some(divide) = unsafe { (*self.calculator).divide } {
            return unsafe { divide(left, right) };
        }

        unreachable!("divide not implemented")
    }

    pub fn store(&self, number: u32) {
        if let Some(store) = unsafe { (*self.calculator).store } {
            unsafe { store(number) }
        } else {
            unreachable!("store not implemented")
        }
    }

    pub fn retrieve(&self) -> u32 {
        if let Some(retrieve) = unsafe { (*self.calculator).retrieve } {
            return unsafe { retrieve() };
        }

        unreachable!("retrieve not implemented")
    }

    pub fn clear(&self) {
        if let Some(clear) = unsafe { (*self.calculator).clear } {
            unsafe { clear() }
        } else {
            unreachable!("clear not implemented")
        }
    }
}

#[no_mangle]
pub extern "C" fn subtract(left: u32, right: u32) -> u32 {
    if left < right {
        return 0;
    }

    left - right
}

#[no_mangle]
pub extern "C" fn multiply(left: u32, right: u32) -> u32 {
    let mut result = 0;
    for _ in 0..right {
        result = unsafe { ffi::add(result, left) };
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_subtract_happy_case() {
        let calculator = Calculator::new();
        let result = calculator.subtract(3, 2);
        assert_eq!(result, 1);
    }

    #[test]
    fn test_subtract_zero() {
        let calculator = Calculator::new();
        let result = calculator.subtract(2, 2);
        assert_eq!(result, 0);
    }

    #[test]
    fn test_subtract_negative_not_supported() {
        let calculator = Calculator::new();
        let result = calculator.subtract(2, 3);
        assert_eq!(result, 0); // no panic
    }

    #[test]
    fn test_multiply() {
        let calculator = Calculator::new();
        let result = calculator.multiply(3, 2);
        assert_eq!(result, 6);
    }

    #[test]
    fn test_add() {
        let calculator = Calculator::new();
        let result = calculator.add(3, 2);
        assert_eq!(result, 5);
    }

    #[test]
    fn test_divide() {
        let calculator = Calculator::new();
        let result = calculator.divide(6, 2);
        assert_eq!(result, 3);
    }

    #[test]
    fn test_divide_by_zero() {
        let calculator = Calculator::new();
        let result = calculator.divide(6, 0);
        assert_eq!(result, 0);
    }

    #[test]
    fn test_memory() {
        let calculator = Calculator::new();
        let result = calculator.retrieve();
        assert_eq!(result, 0);
        calculator.store(42);
        let result = calculator.retrieve();
        assert_eq!(result, 42);
        calculator.clear();
        let result = calculator.retrieve();
        assert_eq!(result, 0);
    }
}
